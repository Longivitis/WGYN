{"files":[{"id":"3772708c-9aed-4620-8055-08b215f4c9f5","name":"Code","type":"server_js","source":"/* \n* We\u0027ve Got Your Number Calculator\n* Author: Martin Nguyen\n*\n* Automatically determines if equations provided from competitors for WGYN is valid\n* given the set of numbers and the intended result. Requires Google Forms for set up\n*\n* infixToPostfix and solvePostfix functions taken from Nic Raboy from thepolyglotdeveloper.\n* added factorials and logarithms within PEMDAS for application of Division C.\n* does not calculate double factorials but rather a factorial of a factorial\n*/\n\n/* \n* calculateScore(): determines scores by adding or subtracting depending on cell background\n* if green increment, if red decrement, yellow do nothing\n* dummy parameter is used to force update when the cells have changed\n* shouldn\u0027t be needed unless I screw up the calculations somehow or reloading the page\n* calculates for one set of nums (1-100)\n* cell should be where the answer 1 column result is located\n* returns score for one set of nums\n*/\nfunction calculateScore(cell, dummy) {\n  var currentCell \u003d SpreadsheetApp.getActiveSpreadsheet().getRange(cell);\n  var score \u003d 0;\n  \n  for(var i \u003d 0; i \u003c 100; i++) {\n    var backgroundColor \u003d currentCell.getBackground();\n    if(backgroundColor \u003d\u003d \"#b7e1cd\")\n      score++;\n    else if(backgroundColor \u003d\u003d \"#f4c7c3\")\n      score--;\n    currentCell \u003d currentCell.offset(0, 1);\n  }\n  \n  SpreadsheetApp.flush();\n  \n  return score;\n}\n\n/* \n* determine background color of the current cell\n* helper method, can use on a specific cell to determine color\n* result will appear on logger\n* not actively used in scoring\n*/\nfunction detBackgroundColor(cell) {\n  var currentCell \u003d SpreadsheetApp.getActiveSpreadsheet().getRange(cell);\n  return currentCell.getBackground();\n}\n\n/* \n* solveFunction()\n* combines three methods to return either the number expected or a 0 if incorrect\n* if the function is blank, returns a blank so no penalty is incurred in scoring\n*/\nfunction solveFunction(equation, numbers, target, division) {\n  if(equation \u003d\u003d \"\") {\n    return \"\";\n  }\n  var isNums \u003d validateNumbers(equation, numbers);\n  var postfix \u003d infixToPostfix(isNums, division);\n  var solution \u003d solvePostfix(postfix, target);\n  return solution;\n}\n\n/* \n* same as solveFunction(), google sheets can be annoying with cache if\n* function breaks midway through processing, have to hard refresh it with this\n*/\nfunction solveFunction2(equation, numbers, target, division) {\n  if(equation \u003d\u003d \"\") {\n    return \"\";\n  }\n  var isNums \u003d validateNumbers(equation, numbers);\n  var postfix \u003d infixToPostfix(isNums, division);\n  var solution \u003d solvePostfix(postfix, target);\n  return solution;\n}\n\n/*\n* validateNumbers(): looks at numbers used in the equation and\n* make sure there are four numbers and they are the correct four numbers\n* otherwise return error, sorts the four numbers from least to greatest\n* if error, returns 0 meaning incorrect in solveFunction()\n* pulls only numbers from the array and sorts them\n*/\nfunction validateNumbers(equation, numbers) {\n  var oldequation \u003d equation;\n  var usedNumbers \u003d \"\";\n  equation \u003d equation.replace(/\\s+/g, \"\");\n  equation \u003d equation.split(/([\\+\\-\\*\\x\\X\\!\\/\\^\\L\\(\\)])/).clean();\n  for(var i \u003d 0; i \u003c equation.length; i++) {\n    var token \u003d equation[i];\n    if(token.isNumeric()) {\n      usedNumbers +\u003d token;\n    }\n  }\n  var numbersArray \u003d [];\n  for(i \u003d 0; i \u003c usedNumbers.length; i++) {\n    numbersArray.push(parseInt(usedNumbers.substring(i, i+1)));\n  }\n  numbersArray.sort();\n  usedNumbers \u003d \"\";\n  for(i \u003d 0; i \u003c numbersArray.length; i++) {\n    token \u003d numbersArray[i];\n    usedNumbers +\u003d token;\n  }  \n  if(parseInt(usedNumbers) \u003d\u003d numbers) {\n    return oldequation;\n  } else {\n    return 0;\n  }\n}\n\n// is this numeric? since expression is not necessarily a string\n// function taken from Nic Raboy from thepolyglotdeveloper.\nString.prototype.isNumeric \u003d function() {\n    return !isNaN(parseFloat(this)) \u0026\u0026 isFinite(this);\n}\n\n// splices depending on parameteres given in the function\n// function taken from Nic Raboy from thepolyglotdeveloper.\nArray.prototype.clean \u003d function() {\n    for(var i \u003d 0; i \u003c this.length; i++) {\n        if(this[i] \u003d\u003d\u003d \"\") {\n            this.splice(i, 1);\n        }\n    }\n    return this;\n}\n\n/*\n* infixToPostfix(): converts infix expression to postfix expression\n* associativity means how to process when same operands are in a row\n* utilizes a stack to push/pop arguments as necessary\n* there is some cleanup at the end to make sure it doesn\u0027t end with a space\n* or else the solvePostfix() function will break for some reason\n* division parameter is to check which functions are valid since\n* division B can\u0027t use logs or factorials\n* if they do use it, the number associated with the operand will disappear,\n* effectively giving the incorrect result\n*/\nfunction infixToPostfix(infix, division) {\n  if(infix \u003d\u003d 0) {\n    return 0;\n  }\n  var outputQueue \u003d \"\";\n  var operatorStack \u003d [];\n  //parenthesis, factorials, exponents/logarithms, mult/divis, add/sub\n  var operators \u003d {\n    \"!\": {\n      precedence: 5,\n      associativity: \"Left\"\n    },\n    \"^\": {\n      precedence: 4,\n      associativity: \"Right\"\n    },\n    \"L\": {\n      precedence: 4,\n      associativity: \"Right\"\n    },\n    \"/\": {\n      precedence: 3,\n      associativity: \"Left\"\n    },\n    \"*\": {\n      precedence: 3,\n      associativity: \"Left\"\n    },\n    \"x\": {\n      precedence: 3,\n      associativity: \"Left\"\n    },\n    \"X\": {\n      precedence: 3,\n      associativity: \"Left\"\n    },\n    \"+\": {\n      precedence: 2,\n      associativity: \"Left\"\n    },\n    \"-\": {\n      precedence: 2,\n      associativity: \"Left\"\n    }\n  }\n  infix \u003d infix.replace(/\\s+/g, \"\");\n  if(division \u003d\u003d \"C\") {\n    infix \u003d infix.split(/([\\+\\-\\*\\x\\X\\!\\/\\^\\L\\(\\)])/).clean();\n  } else {\n    infix \u003d infix.split(/([\\+\\-\\*\\x\\X\\/\\^\\(\\)])/).clean();\n  }\n  for(var i \u003d 0; i \u003c infix.length; i++) {\n    var token \u003d infix[i];\n    if(token.isNumeric()) {\n      outputQueue +\u003d token + \" \";\n    } else if(division \u003d\u003d \"C\" \u0026\u0026 \"^*/+-xX!L\".indexOf(token) !\u003d\u003d -1) {\n      var o1 \u003d token;\n      var o2 \u003d operatorStack[operatorStack.length - 1];\n      while(\"^*/+-xX!L\".indexOf(o2) !\u003d\u003d -1 \u0026\u0026 ((operators[o1].associativity \u003d\u003d\u003d \"Left\" \n            \u0026\u0026 operators[o1].precedence \u003c\u003d operators[o2].precedence) || (operators[o1].associativity \u003d\u003d\u003d \"Right\" \n                                                                         \u0026\u0026 operators[o1].precedence \u003c operators[o2].precedence))) {\n        outputQueue +\u003d operatorStack.pop() + \" \";\n        o2 \u003d operatorStack[operatorStack.length - 1];\n      }\n      operatorStack.push(o1);\n    } else if(division \u003d\u003d \"B\" \u0026\u0026 \"^*/+-xX\".indexOf(token) !\u003d\u003d -1) {\n      var o1 \u003d token;\n      var o2 \u003d operatorStack[operatorStack.length - 1];\n      while(\"^*/+-xX\".indexOf(o2) !\u003d\u003d -1 \u0026\u0026 ((operators[o1].associativity \u003d\u003d\u003d \"Left\" \n            \u0026\u0026 operators[o1].precedence \u003c\u003d operators[o2].precedence) || (operators[o1].associativity \u003d\u003d\u003d \"Right\" \n                                                                         \u0026\u0026 operators[o1].precedence \u003c operators[o2].precedence))) {\n        outputQueue +\u003d operatorStack.pop() + \" \";\n        o2 \u003d operatorStack[operatorStack.length - 1];\n      }\n      operatorStack.push(o1);      \n    } else if(token \u003d\u003d\u003d \"(\") {\n      operatorStack.push(token);\n    } else if(token \u003d\u003d\u003d \")\") {\n      while(operatorStack[operatorStack.length - 1] !\u003d\u003d \"(\") {\n        outputQueue +\u003d operatorStack.pop() + \" \";\n      }\n      operatorStack.pop();\n    }\n  }\n  while(operatorStack.length \u003e 1) {\n    outputQueue +\u003d operatorStack.pop() + \" \";\n  }\n  //prevents ending the outputQueue with a space, which would break solvePostfix()\n  if(operatorStack.length \u003d\u003d 1) {\n    outputQueue +\u003d operatorStack.pop();\n  }\n  if(outputQueue.endsWith(\" \")) {\n    outputQueue \u003d outputQueue.slice(0, -1); \n  }\n  return outputQueue;\n}\n\n/*\n* solvePostfix(): solves the postfix equation and determines if it is equal to the target\n* pushes tokens into the stack one at a time, if an operand is encountered, pop\n* the last two (or one) operands and calculate, then push the result in\n* if function is correct, there should only be one number at the end, which is the result\n* if it is the same as the target, return the result; if not, return 0, signifying it is incorrect\n* must use parseFloat or else division will not result in fractions\n*/\nfunction solvePostfix(postfix, target) {\n  if(postfix \u003d\u003d 0) {\n    return 0;\n  }\n  var resultStack \u003d [];\n  postfix \u003d postfix.split(\" \");\n  for(var i \u003d 0; i \u003c postfix.length; i++) {\n    if(postfix[i].isNumeric()) {\n      resultStack.push(postfix[i]);\n    } else {\n      var a \u003d resultStack.pop();\n      //factorials only require one number, not two\n      if(postfix[i] \u003d\u003d\u003d \"!\") {\n        resultStack.push(parseFloat(factorial(a)));\n      }\n      else {\n        var b \u003d resultStack.pop();\n        if(postfix[i] \u003d\u003d\u003d \"+\") {\n          resultStack.push(parseFloat(a) + parseFloat(b));\n        } else if(postfix[i] \u003d\u003d\u003d \"-\") {\n          resultStack.push(parseFloat(b) - parseFloat(a));\n        } else if(postfix[i] \u003d\u003d\u003d \"*\" || postfix[i] \u003d\u003d\u003d \"x\" || postfix[i] \u003d\u003d\u003d \"X\") {\n          resultStack.push(parseFloat(a) * parseFloat(b));\n        } else if(postfix[i] \u003d\u003d\u003d \"/\") {\n          resultStack.push(parseFloat(parseFloat(b) / parseFloat(a)));\n        } else if(postfix[i] \u003d\u003d\u003d \"^\") {\n          resultStack.push(Math.pow(parseFloat(b), parseFloat(a)));\n        } else if(postfix[i] \u003d\u003d\u003d \"L\") {\n          resultStack.push(Math.log(a) / Math.log(b));\n        }\n      }\n    }\n  }\n  if(resultStack.length \u003e 1) {\n    return 0;\n  } else {\n    var num \u003d resultStack.pop();\n    if(num \u003d\u003d target)\n      return num;\n    else\n      return 0;\n  }\n}\n\n//returns factorial of num\nfunction factorial(num) {\n  var result \u003d num;\n  if (num \u003d\u003d\u003d 0 || num \u003d\u003d\u003d 1) \n    return 1; \n  while (num \u003e 1) { \n    num--;\n    result *\u003d num;\n  }\n  return result;\n}"},{"id":"6e7ccbe6-1033-4d65-862b-204bf9d0997a","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/Mexico_City\",\n  \"dependencies\": {\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\"\n}"}]}